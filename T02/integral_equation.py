import numpy as np

__all__ = ["fr2_mk", "fr2_mpn", "fr2_mzj", "vo2_mk", "frur_mk"]


def fr2_mk(lambd, a, b, nkf, n, kfun, ffun):
    """Розв'язок лiнiйного неоднорiдного iнтегрального рiвняння
    типу Фредгольма другого роду методом замiни iнтеграла скiнченною сумою
    y(x) = f(x) + lambd * \int_{a}^{b} K(x, s) * y(s)ds

    Вхідні дані
    -----------
    lambd : числовий параметр рiвняння.

    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    nkf : 0 =квадратурна формула методу трапецiй;
          1 =квадратурна формула методу Сiмпсона;
          2 =квадратурна формула методу Гаусса;
          3 =квадратурна формула методу Маркова;
          4 =квадратурна формула методу Чебишева.

    n : число точок сiтки. Повинно задовольняти умовi:
        n > 1 при nkf == 0,
        n > 2 і mod(n, 2) == 1 при nkf == 1.

    kfun : функцiя користувача, з описом ядра K(x,s).

    ffun : функцiя користувача, з описом правої частини f(x).

    Вихідні дані
    ------------
    X : масив вузлiв сiтки.

    Y : масив наближеного розв'язку.
    """
    assert a < b, "{} < {}".format(a, b)
    assert -1 < nkf < 5, "Unknown method {}".format(nkf)

    X, P = _fgc(a, b, nkf, n)

    # формування матрицi A(i,k) та вектора правої частини F(i) для СЛАР
    # Y(i) - lambd * SUM(k=1,n, P(k)*K(X(i),X(k))*Y(k) ) = f(X(i)), де i=1,...,n
    A = np.zeros((n, n))

    for i, xi in enumerate(X):
        A[i, :] = -lambd * P * kfun(xi, X)
    np.fill_diagonal(A, A.diagonal() + 1)

    F = ffun(X)

    # розв'язок СЛАР A*Y=F
    Y = np.linalg.solve(A, F)

    return X, Y


def fr2_mpn(lambd, a, b, nkf, n, eps, mki, kfun, ffun):
    """Розв'язок лiнiйного неоднорiдного iнтегрального рiвняння
    типу Фредгольма другого роду методом послiдовних наближень
    y(x) = f(x) + lambd * \int_{a}^{b} K(x, s) * y(s)ds

    Вхідні дані
    -----------
    lambd : числовий параметр рiвняння.

    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    nkf : 0 =квадратурна формула методу трапецiй;
          1 =квадратурна формула методу Сiмпсона;
          2 =квадратурна формула методу Гаусса;
          3 =квадратурна формула методу Маркова;
          4 =квадратурна формула методу Чебишева.

    n : число точок сiтки. Повинно задовольняти умовi:
        n > 1 при nkf == 0,
        n > 2 і mod(n, 2) == 1 при nkf == 1.

    eps : точність (eps > 0).

    kfun : функцiя користувача, з описом ядра K(x,s).

    ffun : функцiя користувача, з описом правої частини f(x).

    Вихідні дані
    ------------
    X : масив вузлiв сiтки.

    Y : масив наближеного розв'язку.
    """
    assert a < b, "{} < {}".format(a, b)
    assert -1 < nkf < 5, "Unknown method {}".format(nkf)
    assert eps > 0, "{} > 0".format(eps)

    X, P = _fgc(a, b, nkf, n)

    # формування матрицi AK(i,j) та вектора FI(i),
    # де AK(i,j)=lambda*P(j)*K(X(i),X(j)), FI(i) = f(X(i)), i=1,...,n; j=1,...,n
    AK = np.zeros((n, n))
    for i, xi in enumerate(X):
        AK[i, :] = lambd * P * kfun(xi, X)

    Y = ffun(X.copy())
    FI = Y.copy()

    # послідовні наближення
    for k in range(mki):
        FI = np.dot(AK, FI)
        Y += FI

        if np.all(np.abs(FI) <= eps):
            break

    return X, Y


def fr2_mzj(lambd, a, b, nkf, n, kfun, ffun):
    """Розв'язок лiнiйного неоднорiдного iнтегрального рiвняння
    типу Фредгольма другого роду методом замiни ядра виродженим
    y(x) = f(x) + lambd * \int_{a}^{b} K(x, s) * y(s)ds,
    де kfun(x, s) = SUM(k=1, m, Ak(x) * Bk(s))

    Вхідні дані
    -----------
    lambd : числовий параметр рiвняння.

    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    nkf : 0 =квадратурна формула методу трапецiй;
          1 =квадратурна формула методу Сiмпсона;
          2 =квадратурна формула методу Гаусса;
          3 =квадратурна формула методу Маркова;
          4 =квадратурна формула методу Чебишева.

    n : число точок сiтки. Повинно задовольняти умовi:
        n > 1 при nkf == 0,
        n > 2 і mod(n, 2) == 1 при nkf == 1.

    kfun : функцiя користувача, з описом ядра K(x,s). Повертає 2 масиви доданків
        [A1(x), ..., Am(x)] та [B1(s), ..., Bm(s)] у виродженому ядрі.

    ffun : функцiя користувача, з описом правої частини f(x).

    Вихідні дані
    ------------
    X : масив вузлiв сiтки.

    Y : масив наближеного розв'язку.
    """
    assert a < b, "{} < {}".format(a, b)
    assert -1 < nkf < 5, "Unknown method {}".format(nkf)

    X, P = _fgc(a, b, nkf, n)

    # формування допомiжних матриць AK, BK i вектора FF,
    # де AK(k,i)=Ak(X(i)), BK(k,i)=Bk(X(i)), FF(i)=f(X(i)), i=1,...,n.
    ABK = kfun(X)
    AK = ABK[0]
    BK = ABK[1]

    FF = ffun(X.copy())

    m = AK.shape[0]  # кількість доданків у виродженому ядрі

    # формування матрицi A i вектора F СЛАР A*C=F,
    # де A(i,j)=if(i=j,1,0)-lambda * SUM(k=1,n, P(k) * AK(j,k) * BK(i,k)),
    # F(i) =SUM(k=1,n, P(k) * FF(k) * BK(i,k)), i=1,...,n
    A = np.zeros((m, m))

    for i in range(m):
        A[i, :] = -lambd * np.sum(P * AK * BK[i, :], axis=1)

    np.fill_diagonal(A, A.diagonal() + 1)

    F = np.sum(P * FF * BK, axis=1)

    # розв'язок СЛАР A*C=F
    C = np.linalg.solve(A, F)

    # розв'язок у виглядi
    # y(x)=fun(x) + lambd * SUM(k=1, m, C(k) * Ak(x))
    Y = FF + lambd * np.dot(C, AK)

    return X, Y


def vo2_mk(lambd, a, b, n, kfun, ffun):
    """Розв'язок лiнiйного неоднорiдного iнтегрального рiвняння типу Вольтерри другого роду методом замiни iнтеграла
    скiнченною сумою (квадратурнi формули методу трапецiй)
    y(x) = f(x) + lambd * \int_{a}^{x}K(x, s) * y(s)ds, x є [a,b]

    Вхідні дані
    -----------
    lambd : числовий параметр рiвняння.

    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    n : число точок сiтки. Повинно задовольняти умовi:
        n > 1 при nkf == 0,
        n > 2 і mod(n, 2) == 1 при nkf == 1.

    kfun : функцiя користувача, з описом ядра K(x,s).

    ffun : функцiя користувача, з описом правої частини f(x).

    Вихідні дані
    ------------
    X : масив вузлiв сiтки.

    Y : масив наближеного розв'язку.
    """
    assert a < b, "{} < {}".format(a, b)

    if n < 2:
        n = 2

    # формування вузлiв
    X = np.linspace(a, b, n)
    h = X[1] - X[0]
    Y = np.zeros(n)
    P = Y.copy()

    # Знаходження розв'язку (СЛАР з лівою трикутною матрицею):
    # Y(i) = (f(X(i)) + lambd*SUM(k=1,i-1, P(k) * K(X(i),X(k)) * Y(k) ))/(1 - lambda * P(i) * K(X(i), X(i))), i=1,...,n.
    for i, xi in enumerate(X):
        # формування коефiцiєнтiв P(j), де j=1,...,i, квадратурної формули
        P[0] = 0.5 * h
        P[1:i] = h
        P[i] = P[0]

        c1 = 0
        for k in range(i):
            c1 += P[k] * kfun(xi, X[k]) * Y[k]
        c1 = ffun(xi) + lambd * c1
        c2 = 1 - lambd * P[0] * kfun(xi, xi)
        Y[i] = c1 / c2

    return X, Y


def frur_mk(a, b, nkf, n, k_dkfun, f_dffun, Y0, eps, mki, m):
    """Розв'язок нелiнiйного iнтегрального рiвняння типу Фредгольма-Урисона
    методом замiни iнтеграла скiнченною сумою
    \int_{a}^{b}K(x,s, y(s))ds = f(x, y(x)), x є [a, b]

    Вхідні дані
    -----------
    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    nkf : 0 =квадратурна формула методу трапецiй;
          1 =квадратурна формула методу Сiмпсона;
          2 =квадратурна формула методу Гаусса;
          3 =квадратурна формула методу Маркова;
          4 =квадратурна формула методу Чебишева.

    n : число точок сiтки. Повинно задовольняти умовi:
        n > 1 при nkf == 0,
        n > 2 і mod(n, 2) == 1 при nkf == 1.

    k_dkfun : функцiя користувача, з описом ядра K(x,s). Повертає 2 масиви доданків
        [A1(x), ..., Am(x)] та [B1(s), ..., Bm(s)] у виродженому ядрі.

    f_dffun : функцiя користувача, з описом правої частини f(x).

    Y : початкове наближення до розв'язку.

    eps : точність (eps > 0)

    mki : максимальна кiлькiсть крокiв iтерацiй.

    m : метод розв'язку нелінійної системи:
        m = 1 - градієнта;
        m = 2 - Ньютона;
        m = 3 - перші 4 ітерації по м.градієнта, далі по м.Ньютона;

    Вихідні дані
    ------------
    X : масив вузлiв сiтки.

    Y : масив наближеного розв'язку.
    """
    assert a < b, "{} < {}".format(a, b)
    assert -1 < nkf < 5, "Unknown method {}".format(nkf)
    assert eps > 0, "{} > 0".format(eps)
    assert 0 < m < 4, "Unknown method {}".format(m)

    X, P = _fgc(a, b, nkf, n)

    F = Y0.copy()
    Y = Y0.copy()
    J = np.zeros((n, n))
    d = np.zeros(n)

    for k in range(mki):
        # знаходження розв'язку нелінійної системи:
        # формування матрицi Якобі J i вектора F
        for i, xi in enumerate(X):
            sk = 0
            for j, pj in enumerate(P):
                k, dk = k_dkfun(xi, X[j], Y[j])
                J[i, j] = pj * dk
                sk += pj * k

            f, df = f_dffun(xi, Y[i])
            J[i, i] -= df
            F[i] = sk - f

        if m == 1 or (m == 3 and k < 3):
            # метод градієнта
            d[:] = np.dot(F, J)
            v = np.dot(d, J)
            sk = np.dot(F, v) / np.dot(v, v)
            d *= sk

        else:
            # метод Ньютона
            d[:] = np.linalg.solve(J, F)

        Y -= d
        if np.linalg.norm(d) <= eps:
            break

    return X, Y.T


def _fgc(a, b, nkf, n):
    """Розбиття відрізка [a, b] на рівні частини та формування коефiцiєнтiв квадраурної формули P.

    Вхідні дані
    -----------
    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    nkf : 0 =квадратурна формула методу трапецiй;
          1 =квадратурна формула методу Сiмпсона;
          2 =квадратурна формула методу Гаусса;
          3 =квадратурна формула методу Маркова;
          4 =квадратурна формула методу Чебишева.

    n : число точок сiтки. Повинно задовольняти умовi:
        n > 1 при nkf == 0,
        n > 2 і mod(n, 2) == 1 при nkf == 1.

    Вихідні дані
    ------------
    X : розбиття відрізка [a, b].

    P : коефіцієнти квадратурної формули.
    """
    if nkf == 0:
        # квадратурна формула методу трапецiй
        if n < 2:
            n = 2

        # формування вузлiв
        X = np.linspace(a, b, n)
        h = X[1] - X[0]
        n1 = n - 1

        # формування коефiцiєнтiв P(i), де i = 1,...,n, квадратурної формули
        P = np.zeros(n)

        P[0] = 0.5 * h
        P[1:n1] = h
        P[n1] = P[0]

    elif nkf == 1:
        # квадратурна формула методу Сiмпсона
        if n < 3:
            n = 3
        elif n % 2 == 0:
            n += 1

        # формування вузлiв
        X = np.linspace(a, b, n)
        h = X[1] - X[0]
        n1 = n - 1

        # формування коефiцiєнтiв P(i), де i = 1,...,n, квадратурної формули
        P = np.zeros(n)

        P[0] = h / 3
        c2 = 2 * P[0]
        c1 = 2 * c2

        P[1:n1:2] = c1
        P[2:n1:2] = c2

        P[n1] = P[0]

    elif nkf == 2:
        # квадратурна формула Гаусса
        assert 1 < n < 8, "not ({} є [2, 7])".format(n)

        X = np.zeros(n)

        if n == 2:
            X[1] = 0.5773502691896258
            X[0] = -X[1]
            P = np.array([0.5, 0.5])

        elif n == 3:
            X[2] = 0.7745966692414834
            X[0] = -X[2]
            P = np.array([5.0, 8.0, 5.0]) / 18

        elif n == 4:
            X[3] = 0.8611363115940492
            X[0] = -X[3]
            X[2] = 0.3399810435848646
            X[1] = -X[2]
            P = np.array([0.1739274225687284, 0.3260725774312716, 0.3260725774312716, 0.1739274225687284])

        elif n == 5:
            X[4] = 0.9061798459386640
            X[0] = -X[4]
            X[3] = 0.5384693101056830
            X[1] = -X[3]
            P = np.array([0.1184634425280945, 0.2393143352496832, 64 / 225, 0.2393143352496832, 0.1184634425280945])

        elif n == 6:
            X[5] = 0.9324695142031520
            X[0] = -X[5]
            X[4] = 0.6612093864662644
            X[1] = -X[4]
            X[3] = 0.2386191860831970
            X[2] = -X[3]
            P = np.array([0.0856622461895852, 0.1803807865240693, 0.2339569672863455,
                          0.2339569672863455, 0.1803807865240693, 0.0856622461895852])

        elif n == 7:
            X[6] = 0.9491079123427596
            X[0] = -X[6]
            X[5] = 0.7415311855993944
            X[1] = -X[5]
            X[4] = 0.4058451513773970
            X[2] = -X[4]
            P = np.array([0.0647424830844348, 0.1398526957446384, 0.1909150252525595, 256 / 1225,
                          0.1909150252525595, 0.1398526957446384, 0.0647424830844348])

        P *= 2

        # якщо [a,b] != [-1,1], то виконуємо лінійне перетворення
        if a != -1.0 or b != 1.0:
            ab = 0.5 * (a + b)
            ba = 0.5 * (b - a)
            X = ab + ba * X
            P *= ba

    elif nkf == 3:
        # квадратурна формула Маркова
        assert 1 < n < 11, "not ({0} є [2, 10])".format(n)

        X = np.linspace(-1.0, 1.0, n)

        if n == 2:
            P = np.ones(n)

        elif n == 3:
            P = np.array([1.0, 4.0, 1.0]) / 3

        elif n == 4:
            X[2] = 1 / 5
            X[1] = -X[2]
            P = np.array([1.0, 5.0, 5.0, 1.0]) / 6

        elif n == 5:
            X[3] = 3 / 7
            X[1] = -X[3]
            P = np.array([9.0, 49.0, 64.0, 49.0, 9.0]) / 90

        elif n == 6:
            X[4] = 0.76505532
            X[1] = -X[4]
            X[3] = 0.28523152
            X[2] = -X[3]
            P = np.array([0.06666667, 0.37847496, 0.55485837, 0.55485837, 0.37847496, 0.06666667])

        elif n == 7:
            X[5] = 0.83022390
            X[1] = -X[5]
            X[4] = 0.46884879
            X[2] = -X[4]
            P = np.array([0.04761905, 0.27682605, 0.43174538, 0.48761905, 0.43174538, 0.27682605, 0.04761905])

        elif n == 8:
            X[6] = 0.87174015
            X[1] = -X[6]
            X[5] = 0.59170018
            X[2] = -X[5]
            X[4] = 0.20929922
            X[1] = -X[4]
            P = np.array(
                [0.03571429, 0.21070423, 0.34112268, 0.41245881, 0.41245881, 0.34112268, 0.21070423, 0.03571429])

        elif n == 9:
            X[7] = 0.83022390
            X[1] = -X[7]
            X[6] = 0.83022390
            X[2] = -X[6]
            X[5] = 0.83022390
            X[3] = -X[5]
            P = np.array([0.02777778, 0.16549536, 0.27453872, 0.34642851, 0.37151927,
                          0.34642851, 0.27453872, 0.16549536, 0.02777778])

        elif n == 10:
            X[8] = 0.91953391
            X[1] = -X[8]
            X[7] = 0.73877386
            X[2] = -X[7]
            X[6] = 0.47792495
            X[3] = -X[6]
            X[5] = 0.16527896
            X[4] = -X[5]
            P = np.array([0.02222222, 0.13330599, 0.22488934, 0.29204268, 0.32753976,
                          0.32753976, 0.29204268, 0.22488934, 0.13330599, 0.02222222])

        # якщо [a,b] != [-1,1], то виконуємо лінійне перетворення
        if a != -1.0 or b != 1.0:
            ab = 0.5 * (a + b)
            ba = 0.5 * (b - a)
            X = ab + ba * X
            P *= ba

    elif nkf == 4:
        assert 1 < n < 8 or n == 9, "not ({0} є [2, 7] or {0} == 9)".format(n)

        X = np.zeros(n)
        P = np.full(n, 2 / n)

        if n == 2:
            X[1] = 0.5773502691
            X[0] = -X[1]

        elif n == 3:
            X[2] = 0.7071067812
            X[0] = -X[2]

        elif n == 4:
            X[3] = 0.7946544723
            X[0] = -X[3]
            X[2] = 0.1875924741
            X[1] = -X[2]

        elif n == 5:
            X[4] = 0.8324974870
            X[0] = -X[4]
            X[3] = 0.3745414096
            X[1] = -X[3]

        elif n == 6:
            X[5] = 0.8662468181
            X[0] = -X[5]
            X[4] = 0.4225186538
            X[1] = -X[4]
            X[3] = 0.2666354015
            X[2] = -X[3]

        elif n == 7:
            X[6] = 0.8838617008
            X[0] = -X[6]
            X[5] = 0.5296567753
            X[1] = -X[5]
            X[4] = 0.3239118105
            X[2] = -X[4]

        elif n == 9:
            X[8] = 0.9115893007
            X[0] = -X[8]
            X[7] = 0.6010186554
            X[1] = -X[7]
            X[6] = 0.5287617831
            X[2] = -X[6]
            X[5] = 0.1679061842
            X[3] = -X[5]

        # якщо [a,b] != [-1,1], то виконуємо лінійне перетворення
        if a != -1.0 or b != 1.0:
            ab = 0.5 * (a + b)
            ba = 0.5 * (b - a)
            X = ab + ba * X
            P *= ba

    return X, P

