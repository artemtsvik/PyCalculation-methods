import numpy as np

__all__ = ["i_trap", "i_simp", "i_gauss", "i_cheb", "i_markov"]


def i_trap(a, b, fun, eps, mki):
    """Знаходження з точнiстью eps значення визначеного iнтеграла
    s = \int_{a}^{b}fun(x)dx
    з допомогою квадратурної формули методу трапецiй.

    Вхiднi данi
    -----------
    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    f : функцiя користувача, з описом fun(x).

    eps : точнiсть (0<eps<1).

    mki : максимальна кiлькiсть згущення сiтки.

    Вихiднi данi
    ------------
    s : значення iнтегралу.
    """
    assert a < b, "{} < {}".format(a, b)
    assert 0 < eps < 1, "0 < {} < 1".format(eps)

    hn = b - a
    S1 = fun(a) + fun(b)
    S2 = 0
    s = 0.5 * hn * S1

    for k in range(mki):
        ho = hn
        hn *= 0.5
        x = a + hn
        while x < b:
            S2 += fun(x)
            x += ho
        ss = 0.5 * hn * (S1 + 2 * S2)
        if abs(ss - s) < 3 * eps:
            break
        s = ss

    return s


def i_simp(a, b, fun, eps, mki):
    """Знаходження з точнiстью eps значення визначеного iнтеграла
    s = \int_{a}^{b}fun(x)dx
    з допомогою квадратурної формули методу Сiмпсона.
    Використовується адаптивний рекурентний алгоритм.

    Вхiднi данi
    -----------
    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    f : функцiя користувача, з описом fun(x).

    eps : точнiсть (0<eps<1).

    mki : максимальна кiлькiсть згущення сiтки.

    Вихiднi данi
    ------------
    s : значення iнтегралу.
    """
    assert a < b, "{} < {}".format(a, b)
    assert 0 < eps < 1, "0 < {} < 1".format(eps)

    hn = 0.5 * (b - a)
    S1 = fun(a) + fun(b)
    S2 = 0
    S4 = fun(0.5 * (b + a))
    s = hn * (S1 + 4 * S4) / 3

    for k in range(mki):
        ho = hn
        hn *= 0.5
        S2 += S4
        S4 = 0
        x = a + hn

        while x < b:
            S4 += fun(x)
            x += ho

        ss = hn * (S1 + 4 * S4 + 2 * S2) / 3
        if abs(ss - s) < 15 * eps:
            break
        s = ss

    return s


def i_gauss(a, b, fun, n):
    """Знаходження визначеного iнтеграла
    s = \int_{a}^{b}fun(x)dx
    з допомогою квадратурної формули Гаусса.

    Вхідні дані
    -----------
    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    fun : функцiя користувача, з описом fun(x).

    n : кiлькiсть вузлів (0<n<8).

    Вихідні дані
    ------------
    s : значення iнтегралу.
    """
    assert a < b, "{} < {}".format(a, b)
    assert 1 < n < 8, "not ({} є [2, 7])".format(n)

    # в залежності від n визначаєм вузли і вагові коефіцієнти
    X = np.zeros(n)

    if n == 2:
        X[1] = 0.5773502691896258
        X[0] = -X[1]
        C = np.array([0.5, 0.5])

    elif n == 3:
        X[2] = 0.7745966692414834
        X[0] = -X[2]
        C = np.array([5.0, 8.0, 5.0]) / 18

    elif n == 4:
        X[3] = 0.8611363115940492
        X[0] = -X[3]
        X[2] = 0.3399810435848646
        X[1] = -X[2]
        C = np.array([0.1739274225687284, 0.3260725774312716, 0.3260725774312716, 0.1739274225687284])

    elif n == 5:
        X[4] = 0.9061798459386640
        X[0] = -X[4]
        X[3] = 0.5384693101056830
        X[1] = -X[3]
        C = np.array([0.1184634425280945, 0.2393143352496832, 64/225, 0.2393143352496832, 0.1184634425280945])

    elif n == 6:
        X[5] = 0.9324695142031520
        X[0] = -X[5]
        X[4] = 0.6612093864662644
        X[1] = -X[4]
        X[3] = 0.2386191860831970
        X[2] = -X[3]
        C = np.array([0.0856622461895852, 0.1803807865240693, 0.2339569672863455,
                      0.2339569672863455, 0.1803807865240693, 0.0856622461895852])

    elif n == 7:
        X[6] = 0.9491079123427596
        X[0] = -X[6]
        X[5] = 0.7415311855993944
        X[1] = -X[5]
        X[4] = 0.4058451513773970
        X[2] = -X[4]
        C = np.array([0.0647424830844348, 0.1398526957446384, 0.1909150252525595, 256/1225,
                      0.1909150252525595, 0.1398526957446384, 0.0647424830844348])

    C *= 2

    # якщо [a,b] != [-1,1], то виконуємо лінійне перетворення
    if a != -1.0 or b != 1.0:
        ab = 0.5 * (a + b)
        ba = 0.5 * (b - a)
        X = ab + ba * X
        C *= ba

    # наближене значення інтеграла
    s = 0
    for xi, ci in zip(X, C):
        s += ci * fun(xi)

    return s


def i_cheb(a, b, fun, n):
    """Знаходження значення визначеного iнтеграла
    s = \int_{a}^{b}fun(x)dx
    з допомогою квадратурної формули Чебишева.

    Вхідні дані
    -----------
    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    fun : функцiя користувача, з описом fun(x).

    n : кiлькiсть вузлів (n є [2,7] або n = 9).

    Вихідні дані
    ------------
    s : значення iнтегралу.
    """
    assert a < b, "{} < {}".format(a, b)
    assert 1 < n < 8 or n == 9, "not ({0} є [2, 7] or {0} == 9)".format(n)

    # в залежності від n визначаєм вузли і вагові коефіцієнти
    X = np.zeros(n)
    C = 2 / n

    if n == 2:
        X[1] = 0.5773502691
        X[0] = -X[1]

    elif n == 3:
        X[2] = 0.7071067812
        X[0] = -X[2]

    elif n == 4:
        X[3] = 0.7946544723
        X[0] = -X[3]
        X[2] = 0.1875924741
        X[1] = -X[2]

    elif n == 5:
        X[4] = 0.8324974870
        X[0] = -X[4]
        X[3] = 0.3745414096
        X[1] = -X[3]

    elif n == 6:
        X[5] = 0.8662468181
        X[0] = -X[5]
        X[4] = 0.4225186538
        X[1] = -X[4]
        X[3] = 0.2666354015
        X[2] = -X[3]

    elif n == 7:
        X[6] = 0.8838617008
        X[0] = -X[6]
        X[5] = 0.5296567753
        X[1] = -X[5]
        X[4] = 0.3239118105
        X[2] = -X[4]

    elif n == 9:
        X[8] = 0.9115893007
        X[0] = -X[8]
        X[7] = 0.6010186554
        X[1] = -X[7]
        X[6] = 0.5287617831
        X[2] = -X[6]
        X[5] = 0.1679061842
        X[3] = -X[5]

    # якщо [a,b] != [-1,1], то виконуємо лінійне перетворення
    if a != -1.0 or b != 1.0:
        ab = 0.5 * (a + b)
        ba = 0.5 * (b - a)
        X = ab + ba * X
        C *= ba

    # наближене значення інтеграла
    s = 0
    for xi in X:
        s += fun(xi)
    s *= C

    return s


def i_markov(a, b, fun, n):
    """Знаходження значення визначеного iнтеграла
    s = \int_{a}^{b}fun(x)dx
    з допомогою квадратурної формули Чебишева.

    Вхідні дані
    -----------
    a : нижня границя iнтеграла.

    b : верхня границя iнтеграла.

    fun : функцiя користувача, з описом fun(x).

    n : кiлькiсть вузлів (n є [2,10]).

    Вихідні дані
    ------------
    s : значення iнтегралу.
    """
    assert a < b, "{} < {}".format(a, b)
    assert 1 < n < 11, "not ({0} є [2, 10])".format(n)

    # в залежності від n визначаєм вузли і вагові коефіцієнти
    X = np.linspace(-1.0, 1.0, n)

    if n == 2:
        C = np.ones(n)

    elif n == 3:
        C = np.array([1.0, 4.0, 1.0]) / 3

    elif n == 4:
        X[2] = 1/5
        X[1] = -X[2]
        C = np.array([1.0, 5.0, 5.0, 1.0]) / 6

    elif n == 5:
        X[3] = 3 / 7
        X[1] = -X[3]
        C = np.array([9.0, 49.0, 64.0, 49.0, 9.0]) / 90

    elif n == 6:
        X[4] = 0.76505532
        X[1] = -X[4]
        X[3] = 0.28523152
        X[2] = -X[3]
        C = np.array([0.06666667, 0.37847496, 0.55485837, 0.55485837, 0.37847496, 0.06666667])

    elif n == 7:
        X[5] = 0.83022390
        X[1] = -X[5]
        X[4] = 0.46884879
        X[2] = -X[4]
        C = np.array([0.04761905, 0.27682605, 0.43174538, 0.48761905, 0.43174538, 0.27682605, 0.04761905])

    elif n == 8:
        X[6] = 0.87174015
        X[1] = -X[6]
        X[5] = 0.59170018
        X[2] = -X[5]
        X[4] = 0.20929922
        X[1] = -X[4]
        C = np.array([0.03571429, 0.21070423, 0.34112268, 0.41245881, 0.41245881, 0.34112268, 0.21070423, 0.03571429])

    elif n == 9:
        X[7] = 0.83022390
        X[1] = -X[7]
        X[6] = 0.83022390
        X[2] = -X[6]
        X[5] = 0.83022390
        X[3] = -X[5]
        C = np.array([0.02777778, 0.16549536, 0.27453872, 0.34642851, 0.37151927,
                      0.34642851, 0.27453872, 0.16549536, 0.02777778])

    elif n == 10:
        X[8] = 0.91953391
        X[1] = -X[8]
        X[7] = 0.73877386
        X[2] = -X[7]
        X[6] = 0.47792495
        X[3] = -X[6]
        X[5] = 0.16527896
        X[4] = -X[5]
        C = np.array([0.02222222, 0.13330599, 0.22488934, 0.29204268, 0.32753976,
                      0.32753976, 0.29204268, 0.22488934, 0.13330599, 0.02222222])

    # якщо [a,b] != [-1,1], то виконуємо лінійне перетворення
    if a != -1.0 or b != 1.0:
        ab = 0.5 * (a + b)
        ba = 0.5 * (b - a)
        X = ab + ba * X
        C *= ba

    # наближене значення інтеграла
    s = 0
    for xi, ci in zip(X, C):
        s += ci * fun(xi)

    return s



